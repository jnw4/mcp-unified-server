/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import { sandboxesCreateDirectory } from "../funcs/sandboxesCreateDirectory.js";
import { sandboxesCreateSnapshot } from "../funcs/sandboxesCreateSnapshot.js";
import { sandboxesDeleteSnapshot } from "../funcs/sandboxesDeleteSnapshot.js";
import { sandboxesExtendSandboxTimeout } from "../funcs/sandboxesExtendSandboxTimeout.js";
import { sandboxesGetCommand } from "../funcs/sandboxesGetCommand.js";
import { sandboxesGetCommandLogs } from "../funcs/sandboxesGetCommandLogs.js";
import { sandboxesGetSandbox } from "../funcs/sandboxesGetSandbox.js";
import { sandboxesGetSnapshot } from "../funcs/sandboxesGetSnapshot.js";
import { sandboxesKillCommand } from "../funcs/sandboxesKillCommand.js";
import { sandboxesListCommands } from "../funcs/sandboxesListCommands.js";
import { sandboxesListSandboxes } from "../funcs/sandboxesListSandboxes.js";
import { sandboxesListSnapshots } from "../funcs/sandboxesListSnapshots.js";
import { sandboxesReadFile } from "../funcs/sandboxesReadFile.js";
import { sandboxesRunCommand, } from "../funcs/sandboxesRunCommand.js";
import { sandboxesStopSandbox } from "../funcs/sandboxesStopSandbox.js";
import { sandboxesUpdateNetworkPolicy } from "../funcs/sandboxesUpdateNetworkPolicy.js";
import { sandboxesWriteFiles } from "../funcs/sandboxesWriteFiles.js";
import { ClientSDK } from "../lib/sdks.js";
import { unwrapAsync } from "../types/fp.js";
export { RunCommandAcceptEnum } from "../funcs/sandboxesRunCommand.js";
export class Sandboxes extends ClientSDK {
    /**
     * List sandboxes
     *
     * @remarks
     * Retrieves a paginated list of sandboxes belonging to a specific project. Results can be filtered by creation time using the `since` and `until` parameters.
     */
    async listSandboxes(request, options) {
        return unwrapAsync(sandboxesListSandboxes(this, request, options));
    }
    /**
     * List snapshots
     *
     * @remarks
     * Retrieves a paginated list of snapshots for a specific project.
     */
    async listSnapshots(request, options) {
        return unwrapAsync(sandboxesListSnapshots(this, request, options));
    }
    /**
     * Get a sandbox
     *
     * @remarks
     * Retrieves detailed information about a specific sandbox, including its current status, resource configuration, and exposed routes.
     */
    async getSandbox(request, options) {
        return unwrapAsync(sandboxesGetSandbox(this, request, options));
    }
    /**
     * List commands
     *
     * @remarks
     * Retrieves a list of all commands that have been executed in a sandbox, including their current status, exit codes, and execution times.
     */
    async listCommands(request, options) {
        return unwrapAsync(sandboxesListCommands(this, request, options));
    }
    /**
     * Execute a command
     *
     * @remarks
     * Executes a shell command inside a running sandbox. The command runs asynchronously and returns immediately with a command ID that can be used to track its progress and retrieve its output. Optionally, use the `wait` parameter to stream the command status until completion.
     */
    async runCommand(request, options) {
        return unwrapAsync(sandboxesRunCommand(this, request, options));
    }
    /**
     * Kill a command
     *
     * @remarks
     * Sends a signal to terminate a running command in a sandbox. The signal can be used to gracefully stop (SIGTERM) or forcefully kill (SIGKILL) the process. The command must still be running for this operation to succeed.
     */
    async killCommand(request, options) {
        return unwrapAsync(sandboxesKillCommand(this, request, options));
    }
    /**
     * Stop a sandbox
     *
     * @remarks
     * Stops a running sandbox and releases its allocated resources. All running processes within the sandbox will be terminated. This action cannot be undone. A stopped sandbox cannot be restarted.
     */
    async stopSandbox(request, options) {
        return unwrapAsync(sandboxesStopSandbox(this, request, options));
    }
    /**
     * Extend sandbox timeout
     *
     * @remarks
     * Extends the maximum execution time of a running sandbox. The sandbox must be active and able to accept commands. The total timeout cannot exceed the maximum allowed limit for your account.
     */
    async extendSandboxTimeout(request, options) {
        return unwrapAsync(sandboxesExtendSandboxTimeout(this, request, options));
    }
    /**
     * Update network policy
     *
     * @remarks
     * Replaces the network access policy of a running sandbox. Use this to control which external hosts the sandbox can communicate with. This is a full replacement. Any previously configured network rules will be overwritten.
     */
    async updateNetworkPolicy(request, options) {
        return unwrapAsync(sandboxesUpdateNetworkPolicy(this, request, options));
    }
    /**
     * Get a command
     *
     * @remarks
     * Retrieves the current status and details of a command executed in a sandbox. Use the `wait` parameter to block until the command finishes execution.
     */
    async getCommand(request, options) {
        return unwrapAsync(sandboxesGetCommand(this, request, options));
    }
    /**
     * Stream command logs
     *
     * @remarks
     * Streams the output of a command in real-time using newline-delimited JSON (ND-JSON). Each entry includes the output data and stream type. Stream types include `stdout`, `stderr`, and `error` (for stream failures).
     */
    async getCommandLogs(request, options) {
        return unwrapAsync(sandboxesGetCommandLogs(this, request, options));
    }
    /**
     * Read a file
     *
     * @remarks
     * Downloads the contents of a file from a sandbox's filesystem. The file content is returned as a binary stream with appropriate Content-Disposition headers for file download.
     */
    async readFile(request, options) {
        return unwrapAsync(sandboxesReadFile(this, request, options));
    }
    /**
     * Create a directory
     *
     * @remarks
     * Creates a new directory in a sandbox's filesystem. By default, parent directories are created recursively if they don't exist (similar to `mkdir -p`).
     */
    async createDirectory(request, options) {
        return unwrapAsync(sandboxesCreateDirectory(this, request, options));
    }
    /**
     * Write files
     *
     * @remarks
     * Uploads and extracts files to a sandbox's filesystem. Files must be uploaded as a gzipped tarball (`.tar.gz`) with the `Content-Type` header set to `application/gzip`. The tarball contents are extracted to the sandbox's working directory, or to a custom directory specified via the `x-cwd` header.
     */
    async writeFiles(request, options) {
        return unwrapAsync(sandboxesWriteFiles(this, request, options));
    }
    /**
     * Get a snapshot
     *
     * @remarks
     * Retrieves detailed information about a specific snapshot, including its creation time, size, expiration date, and the source sandbox it was created from.
     */
    async getSnapshot(request, options) {
        return unwrapAsync(sandboxesGetSnapshot(this, request, options));
    }
    /**
     * Delete a snapshot
     *
     * @remarks
     * Permanently deletes a snapshot and frees its associated storage. This action cannot be undone. After deletion, the snapshot can no longer be used to create new sandboxes.
     */
    async deleteSnapshot(request, options) {
        return unwrapAsync(sandboxesDeleteSnapshot(this, request, options));
    }
    /**
     * Create a snapshot
     *
     * @remarks
     * Creates a point-in-time snapshot of a running sandbox's filesystem. Snapshots can be used to quickly restore a sandbox to a previous state or to create new sandboxes with pre-configured environments. The sandbox must be running and able to accept commands for a snapshot to be created. The sandbox will be terminated after the snapshot is created.
     */
    async createSnapshot(request, options) {
        return unwrapAsync(sandboxesCreateSnapshot(this, request, options));
    }
}
//# sourceMappingURL=sandboxes.js.map