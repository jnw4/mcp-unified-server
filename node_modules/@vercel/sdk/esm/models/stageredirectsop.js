/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
/** @internal */
export const StatusCode$inboundSchema = smartUnion([types.number(), types.string()]);
/** @internal */
export const StatusCode$outboundSchema = smartUnion([z.number(), z.string()]);
export function statusCodeToJSON(statusCode) {
    return JSON.stringify(StatusCode$outboundSchema.parse(statusCode));
}
export function statusCodeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StatusCode$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StatusCode' from JSON`);
}
/** @internal */
export const Redirects$inboundSchema = z.object({
    source: types.string(),
    destination: types.string(),
    statusCode: types.optional(smartUnion([types.number(), types.string()])),
    permanent: types.optional(types.boolean()),
    caseSensitive: types.optional(types.boolean()),
    query: types.optional(types.boolean()),
    preserveQueryParams: types.optional(types.boolean()),
});
/** @internal */
export const Redirects$outboundSchema = z.object({
    source: z.string(),
    destination: z.string(),
    statusCode: smartUnion([z.number(), z.string()]).optional(),
    permanent: z.boolean().optional(),
    caseSensitive: z.boolean().optional(),
    query: z.boolean().optional(),
    preserveQueryParams: z.boolean().optional(),
});
export function redirectsToJSON(redirects) {
    return JSON.stringify(Redirects$outboundSchema.parse(redirects));
}
export function redirectsFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Redirects$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Redirects' from JSON`);
}
/** @internal */
export const StageRedirectsRequestBody$inboundSchema = z.object({
    projectId: types.string(),
    teamId: types.string(),
    overwrite: types.optional(types.boolean()),
    name: types.optional(types.string()),
    redirects: types.optional(z.array(z.lazy(() => Redirects$inboundSchema))),
});
/** @internal */
export const StageRedirectsRequestBody$outboundSchema = z.object({
    projectId: z.string(),
    teamId: z.string(),
    overwrite: z.boolean().optional(),
    name: z.string().optional(),
    redirects: z.array(z.lazy(() => Redirects$outboundSchema)).optional(),
});
export function stageRedirectsRequestBodyToJSON(stageRedirectsRequestBody) {
    return JSON.stringify(StageRedirectsRequestBody$outboundSchema.parse(stageRedirectsRequestBody));
}
export function stageRedirectsRequestBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StageRedirectsRequestBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StageRedirectsRequestBody' from JSON`);
}
/** @internal */
export const StageRedirectsRequest$inboundSchema = z.object({
    teamId: types.optional(types.string()),
    slug: types.optional(types.string()),
    RequestBody: types.optional(z.lazy(() => StageRedirectsRequestBody$inboundSchema)),
}).transform((v) => {
    return remap$(v, {
        "RequestBody": "requestBody",
    });
});
/** @internal */
export const StageRedirectsRequest$outboundSchema = z.object({
    teamId: z.string().optional(),
    slug: z.string().optional(),
    requestBody: z.lazy(() => StageRedirectsRequestBody$outboundSchema)
        .optional(),
}).transform((v) => {
    return remap$(v, {
        requestBody: "RequestBody",
    });
});
export function stageRedirectsRequestToJSON(stageRedirectsRequest) {
    return JSON.stringify(StageRedirectsRequest$outboundSchema.parse(stageRedirectsRequest));
}
export function stageRedirectsRequestFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StageRedirectsRequest$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StageRedirectsRequest' from JSON`);
}
/** @internal */
export const StageRedirectsVersion$inboundSchema = z.object({
    id: types.string(),
    key: types.string(),
    lastModified: types.number(),
    createdBy: types.string(),
    name: types.optional(types.string()),
    isStaging: types.optional(types.boolean()),
    isLive: types.optional(types.boolean()),
    redirectCount: types.optional(types.number()),
    alias: types.optional(types.string()),
});
/** @internal */
export const StageRedirectsVersion$outboundSchema = z.object({
    id: z.string(),
    key: z.string(),
    lastModified: z.number(),
    createdBy: z.string(),
    name: z.string().optional(),
    isStaging: z.boolean().optional(),
    isLive: z.boolean().optional(),
    redirectCount: z.number().optional(),
    alias: z.string().optional(),
});
export function stageRedirectsVersionToJSON(stageRedirectsVersion) {
    return JSON.stringify(StageRedirectsVersion$outboundSchema.parse(stageRedirectsVersion));
}
export function stageRedirectsVersionFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StageRedirectsVersion$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StageRedirectsVersion' from JSON`);
}
/** @internal */
export const StageRedirectsResponseBody$inboundSchema = z.object({
    alias: types.nullable(types.string()),
    version: z.lazy(() => StageRedirectsVersion$inboundSchema),
});
/** @internal */
export const StageRedirectsResponseBody$outboundSchema = z.object({
    alias: z.nullable(z.string()),
    version: z.lazy(() => StageRedirectsVersion$outboundSchema),
});
export function stageRedirectsResponseBodyToJSON(stageRedirectsResponseBody) {
    return JSON.stringify(StageRedirectsResponseBody$outboundSchema.parse(stageRedirectsResponseBody));
}
export function stageRedirectsResponseBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StageRedirectsResponseBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StageRedirectsResponseBody' from JSON`);
}
//# sourceMappingURL=stageredirectsop.js.map