/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as types from "../types/primitives.js";
export const GetBypassIpAction = {
    Bypass: "bypass",
    Block: "block",
};
/** @internal */
export const GetBypassIpRequest$inboundSchema = z.object({
    projectId: types.string(),
    limit: types.optional(types.number()),
    sourceIp: types.optional(types.string()),
    domain: types.optional(types.string()),
    projectScope: types.optional(types.boolean()),
    offset: types.optional(types.string()),
    teamId: types.optional(types.string()),
    slug: types.optional(types.string()),
});
/** @internal */
export const GetBypassIpRequest$outboundSchema = z.object({
    projectId: z.string(),
    limit: z.number().optional(),
    sourceIp: z.string().optional(),
    domain: z.string().optional(),
    projectScope: z.boolean().optional(),
    offset: z.string().optional(),
    teamId: z.string().optional(),
    slug: z.string().optional(),
});
export function getBypassIpRequestToJSON(getBypassIpRequest) {
    return JSON.stringify(GetBypassIpRequest$outboundSchema.parse(getBypassIpRequest));
}
export function getBypassIpRequestFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpRequest$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpRequest' from JSON`);
}
/** @internal */
export const GetBypassIpAction$inboundSchema = z.nativeEnum(GetBypassIpAction);
/** @internal */
export const GetBypassIpAction$outboundSchema = GetBypassIpAction$inboundSchema;
/** @internal */
export const GetBypassIpResult$inboundSchema = z.object({
    OwnerId: types.string(),
    Id: types.string(),
    Domain: types.string(),
    Ip: types.string(),
    Action: types.optional(GetBypassIpAction$inboundSchema),
    ProjectId: types.optional(types.string()),
    IsProjectRule: types.optional(types.boolean()),
    Note: types.optional(types.string()),
    CreatedAt: types.string(),
    ActorId: types.optional(types.string()),
    UpdatedAt: types.string(),
    UpdatedAtHour: types.string(),
    DeletedAt: types.optional(types.string()),
    ExpiresAt: z.nullable(types.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
        "Domain": "domain",
        "Ip": "ip",
        "Action": "action",
        "ProjectId": "projectId",
        "IsProjectRule": "isProjectRule",
        "Note": "note",
        "CreatedAt": "createdAt",
        "ActorId": "actorId",
        "UpdatedAt": "updatedAt",
        "UpdatedAtHour": "updatedAtHour",
        "DeletedAt": "deletedAt",
        "ExpiresAt": "expiresAt",
    });
});
/** @internal */
export const GetBypassIpResult$outboundSchema = z.object({
    ownerId: z.string(),
    id: z.string(),
    domain: z.string(),
    ip: z.string(),
    action: GetBypassIpAction$outboundSchema.optional(),
    projectId: z.string().optional(),
    isProjectRule: z.boolean().optional(),
    note: z.string().optional(),
    createdAt: z.string(),
    actorId: z.string().optional(),
    updatedAt: z.string(),
    updatedAtHour: z.string(),
    deletedAt: z.string().optional(),
    expiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
        domain: "Domain",
        ip: "Ip",
        action: "Action",
        projectId: "ProjectId",
        isProjectRule: "IsProjectRule",
        note: "Note",
        createdAt: "CreatedAt",
        actorId: "ActorId",
        updatedAt: "UpdatedAt",
        updatedAtHour: "UpdatedAtHour",
        deletedAt: "DeletedAt",
        expiresAt: "ExpiresAt",
    });
});
export function getBypassIpResultToJSON(getBypassIpResult) {
    return JSON.stringify(GetBypassIpResult$outboundSchema.parse(getBypassIpResult));
}
export function getBypassIpResultFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResult$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResult' from JSON`);
}
/** @internal */
export const GetBypassIpPagination$inboundSchema = z.object({
    OwnerId: types.string(),
    Id: types.string(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
    });
});
/** @internal */
export const GetBypassIpPagination$outboundSchema = z.object({
    ownerId: z.string(),
    id: z.string(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
    });
});
export function getBypassIpPaginationToJSON(getBypassIpPagination) {
    return JSON.stringify(GetBypassIpPagination$outboundSchema.parse(getBypassIpPagination));
}
export function getBypassIpPaginationFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpPagination$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpPagination' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBody$inboundSchema = z.object({
    result: z.array(z.lazy(() => GetBypassIpResult$inboundSchema)),
    pagination: types.optional(z.lazy(() => GetBypassIpPagination$inboundSchema)),
});
/** @internal */
export const GetBypassIpResponseBody$outboundSchema = z.object({
    result: z.array(z.lazy(() => GetBypassIpResult$outboundSchema)),
    pagination: z.lazy(() => GetBypassIpPagination$outboundSchema).optional(),
});
export function getBypassIpResponseBodyToJSON(getBypassIpResponseBody) {
    return JSON.stringify(GetBypassIpResponseBody$outboundSchema.parse(getBypassIpResponseBody));
}
export function getBypassIpResponseBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBody' from JSON`);
}
//# sourceMappingURL=getbypassipop.js.map