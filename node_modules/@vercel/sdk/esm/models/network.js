/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as types from "../types/primitives.js";
/**
 * The status of the Network.
 */
export const Status = {
    CreateInProgress: "create_in_progress",
    DeleteInProgress: "delete_in_progress",
    Error: "error",
    Ready: "ready",
};
/** @internal */
export const HostedZones$inboundSchema = z.object({
    count: types.number(),
});
/** @internal */
export const HostedZones$outboundSchema = z.object({
    count: z.number(),
});
export function hostedZonesToJSON(hostedZones) {
    return JSON.stringify(HostedZones$outboundSchema.parse(hostedZones));
}
export function hostedZonesFromJSON(jsonString) {
    return safeParse(jsonString, (x) => HostedZones$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'HostedZones' from JSON`);
}
/** @internal */
export const PeeringConnections$inboundSchema = z.object({
    count: types.number(),
});
/** @internal */
export const PeeringConnections$outboundSchema = z.object({
    count: z.number(),
});
export function peeringConnectionsToJSON(peeringConnections) {
    return JSON.stringify(PeeringConnections$outboundSchema.parse(peeringConnections));
}
export function peeringConnectionsFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PeeringConnections$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PeeringConnections' from JSON`);
}
/** @internal */
export const Projects$inboundSchema = z.object({
    count: types.number(),
    ids: z.array(types.string()),
});
/** @internal */
export const Projects$outboundSchema = z.object({
    count: z.number(),
    ids: z.array(z.string()),
});
export function projectsToJSON(projects) {
    return JSON.stringify(Projects$outboundSchema.parse(projects));
}
export function projectsFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Projects$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Projects' from JSON`);
}
/** @internal */
export const Status$inboundSchema = z
    .nativeEnum(Status);
/** @internal */
export const Status$outboundSchema = Status$inboundSchema;
/** @internal */
export const Network$inboundSchema = z.object({
    awsAccountId: types.string(),
    awsAvailabilityZoneIds: types.optional(z.array(types.string())),
    awsRegion: types.string(),
    cidr: types.string(),
    createdAt: types.number(),
    egressIpAddresses: types.optional(z.array(types.string())),
    hostedZones: types.optional(z.lazy(() => HostedZones$inboundSchema)),
    id: types.string(),
    name: types.string(),
    peeringConnections: types.optional(z.lazy(() => PeeringConnections$inboundSchema)),
    projects: types.optional(z.lazy(() => Projects$inboundSchema)),
    region: types.optional(types.string()),
    status: Status$inboundSchema,
    teamId: types.string(),
    vpcId: types.optional(types.string()),
});
/** @internal */
export const Network$outboundSchema = z.object({
    awsAccountId: z.string(),
    awsAvailabilityZoneIds: z.array(z.string()).optional(),
    awsRegion: z.string(),
    cidr: z.string(),
    createdAt: z.number(),
    egressIpAddresses: z.array(z.string()).optional(),
    hostedZones: z.lazy(() => HostedZones$outboundSchema).optional(),
    id: z.string(),
    name: z.string(),
    peeringConnections: z.lazy(() => PeeringConnections$outboundSchema)
        .optional(),
    projects: z.lazy(() => Projects$outboundSchema).optional(),
    region: z.string().optional(),
    status: Status$outboundSchema,
    teamId: z.string(),
    vpcId: z.string().optional(),
});
export function networkToJSON(network) {
    return JSON.stringify(Network$outboundSchema.parse(network));
}
export function networkFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Network$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Network' from JSON`);
}
//# sourceMappingURL=network.js.map